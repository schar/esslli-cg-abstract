%\begin{pre}
\documentclass[11pt,twocolumn,a4paper]{bqhatevwr}
\usepackage{etex,amsmath,mathtools,newtxtext,newtxmath,expex,natbib,tikz-qtree,bookmark,tree-dvips}%
\usepackage[margin=1in]{geometry}
\usepackage{bussproofs}\EnableBpAbbreviations
\usepackage{caption}
\usepackage{subcaption}
\newcommand{\pruf}[1]{\def\ScoreOverhang{0pt}\def\defaultHypSeparation{\hskip .25em}#1\DisplayProof}%
\newcommand{\lab}[1]{\RightLabel{\scriptsize #1}}
\newcommand{\pt}{\hspace{1pt}}
\newcommand{\ppt}{\hspace{2pt}}
\newcommand{\dt}{\pt.\ppt}
\renewcommand{\ra}{\ensuremath{\shortrightarrow}}
\usepackage{enumitem}
\setlist[itemize]{leftmargin=0pt}
\def\labelitemi{} 
\lingset{exskip=.5em}
\delimitershortfall=-1pt
\bibliographystyle{bqhatevwr}
\author[D.~Bumford \& S.~Charlow]{\spauthor{Dylan Bumford \\ \institute{NYU}} \AND
  \spauthor{Simon Charlow \\ \institute{Rutgers}} \AND
}
\title{Monadic dynamic semantics}
%\end{pre}
\begin{document}
%\maketitle

\section{Overview}
%\begin{sec}
  \textbf{C}ontinuized \textbf{C}ombinatory \textbf{C}ategorial \textbf{G}rammars supplement traditional applicative categorial grammars with a small number of combinators that allow expressions to take scope over their compositional contexts \citep[e.g.][]{ShanBarker:2006, BarkerShan:2008, BarkerShan:2014}. Though CCCGs offer robust accounts of in-scope binding (ibid.), the treatment of dynamic binding (i.e.~cross-sentential and donkey anaphora) proposed in \citealt{BarkerShan:2008} overgenerates (\citealt{Charlow:2010}; see \citealt{BarkerShan:2014} for in-depth discussion). Conversely, the related theory of \citealt{Groote:2006} (which relies on continuations, but is not a CCG) handles dynamic binding elegantly, but does not offer any general account of scope-taking. In addition, both \citealt{BarkerShan:2008} and \citealt{Groote:2006} analyze dynamic binding by indefinites, but not by expressions such as \emph{exactly one linguist}, which differs in important ways \citep[cf.][]{KampReyle:1993}. %
	
  This paper presents an explicit CCCG account of dynamic binding inspired by the computer science notion of a \emph{monad} \citep[e.g.][]{Moggi:1989, Wadler:1992, Wadler:1994, Wadler:1995, Shan:2002}. Monads were developed as an abstraction for structuring extensions to the pure lambda calculus; they enable us to modularly add \emph{side effects} \citep[cf.][]{Shan:2005} to a programming language or natural language grammar. It is proposed that dynamic binding can be captured by recognizing two kinds of linguistic side effects: \textbf{state} and \textbf{nondeterminism}. State corresponds to the ability to introduce discourse referents, while nondeterminism means the ability to track multiple computations in parallel, which facilitates a referential treatment of indefinite expressions. %
	
  Concretely, a monad determines a pair of combinators \ab{\eta,\,\star}, one for wrapping values inside trivially effectful structures, and another for composing programs with potential side effects. Our proposal is to replace the standard lifting and lowering operations of CCCGs with (respectively) $\star$ and $\eta$. Combined with some intuitive lexical entries, this has the automatic effect of producing a CCCG that countenances side effects. Crucially, given the underlying continuations-based scaffolding, the problem of integrating well-motivated combinatorial approaches to scope with insights from dynamic semantics reduces to finding a monad for state and nondeterminism. Though we focus on the case of dynamic binding here, any system of effects can be grafted onto a continuized CCG in this way.%
%\end{sec}

\section{Continuations}
%\begin{sec}
  Simplifying somewhat,\footnote{In particular, abstracting away from the multimodal presentation of \citealt{ShanBarker:2006, BarkerShan:2008, BarkerShan:2014}.}we take it that a standard CCCG consists of three polymorphic combinators, \bsf{Lift}, \bsf{Triv}, and \bsf{Scope}, in addition to the basic categorial slashes that encode forward and backward function application. These combinators are defined in Figure~\ref{fig1} (along with a characterization of the slashes' behavior). The inference rules make use of a type constructor $\textsf{K}$ parameterized by two concrete types. Formally, $\textsf{K}\,a\,r \Coloneqq r/(r/a)$; the $r/a$ argument to something of type $\textsf{K}\,a\,r$ is called its \emph{continuation}, and represents the denotation of its context. Intuitively, expressions with type $\textsf{K}\,a\,r$ behave like things of type $a$ within compositional contexts of type $r$ (the `result type') of the computation. For example, extensional generalized quantifiers have type $\textsf{K}\,e\,t$, since they behave locally as individuals but quantify over constituents of type $t$.%

  As for combinators, \bsf{Lift} turns any expression into a function on its \emph{continuation}; it is a polymorphic generalization of the familiar lifting procedure that converts individuals to the corresponding principal ultrafilters (cf.~\citealt{Montague:1974}). \bsf{Scope} defines the compositional process whereby two continuized expressions are combined, giving the left scope over the right. Finally, \bsf{Triv} is a trivial continuation used to delimit contexts of evaluation and expose underlying semantic values. \citealt{ShanBarker:2006} show that these three operations suffice to derive cases of inverse scope (that is, where an expression scopes over something to its left).%
\begin{figure*}
  \small
  \begin{subfigure}[b]{\textwidth}
    \[%
      \begin{array}{@{}c@{}}
        \begin{array}{c@{\hspace{2em}}c}
          \pruf{%
            \AXC{$\Gamma \vdash f : b/a~~$}
            \AXC{$~~\Delta \vdash e : a$}
            \lab{$/$}
            \BIC{$\Gamma \cdot \Delta \vdash f\,e : b$}
          }
          &
          \pruf{%
            \AXC{$\Delta \vdash e : a~~$}
            \AXC{$~~\Gamma \vdash f : a \backslash b$}
            \lab{$\backslash$}
            \BIC{$\Delta \cdot \Gamma \vdash f\,e : b$}
          }
        \end{array}
        \\
        \begin{array}{c@{\hspace{2em}}c@{\hspace{2em}}c@{\hspace{2em}}c}%
          \pruf{%
            \AXC{\vphantom{f}}
            \lab{\bsf{Triv}}
            \UIC{$\varepsilon \vdash \lambda x.\,x : a/a$}
          }
          &
          \pruf{%
            \AXC{\vphantom{f}}
            \lab{\bsf{Lift}}
            \UIC{$\varepsilon \vdash \lambda xk.\,k\,x:  a / \textsf{K}\,a\,r$}%
          }
          &
          \pruf{%
            \AXC{\vphantom{f}}
            \lab{\bsf{Scope}}
            \UIC{%
              $\varepsilon \vdash \bsf{S} :
              (\textsf{K}\,b\,r / \textsf{K}\,a\,r) / \textsf{K}\,(b/a)\,r$
            }
            % \AXC{$\Delta \vdash m : \textsf{K}\,(b/a)\,r~~$}
            % \AXC{$~~\Gamma \vdash n : \textsf{K}\,a\,r$}
            % \lab{$\sslash$}
            % \BIC{$\Delta \cdot \Gamma \vdash \bsf{S}\,m\,n : \textsf{K}\,b\,r$}
          }
        \end{array}
      \end{array}
    \]
		\caption{Continuized CCG without side effects, fixing a result type $r$.}%
		\label{fig1}
  \end{subfigure} \\[1em]
  \begin{subfigure}[b]{\textwidth}
    \[
      \begin{array}{c}
        \begin{array}{c@{\hspace{2em}}c}
          \pruf{%
          \AXC{$\Gamma \vdash f : b/a~~$}
          \AXC{$~~\Delta \vdash e : a$}
          \lab{$/$}
          \BIC{$\Gamma \cdot \Delta \vdash f\,e : b$}
          }
          &
          \pruf{%
          \AXC{$\Delta \vdash e : a~~$}
          \AXC{$~~\Gamma \vdash f : a \backslash b$}
          \lab{$\backslash$}
          \BIC{$\Delta \cdot \Gamma \vdash f\,e : b$}
          }
        \end{array}
        \\
        \begin{array}{c@{\hspace{2em}}c@{\hspace{2em}}c@{\hspace{2em}}c}%
          \pruf{%
          \AXC{\vphantom{f}}
          \lab{$\eta$}
          \UIC{$\varepsilon \vdash \eta : \textsf{M}\,a / a$}
          }
          &
          \pruf{%
          \AXC{\vphantom{f}}
          \lab{$\star$}
          \UIC{%
            $\varepsilon \vdash (\star) :
            \textsf{K}\,a\,\textsf{M}\,r / \textsf{M}\,a$
          }
          }
          &
          \pruf{%
          \AXC{\vphantom{f}}
          \lab{\bsf{Scope}}
          \UIC{%
            $\varepsilon \vdash \bsf{S} :
            (\textsf{K}\,b\,r / \textsf{K}\,a\,r) / \textsf{K}\,(b/a)\,r$
          }
          % \AXC{$\Delta \vdash m : \textsf{K}\,(b/a)\,r~~$}
          % \AXC{$~~\Gamma \vdash n : \textsf{K}\,a\,r$}
          % \lab{$\sslash$}
          % \BIC{$\Delta \cdot \Gamma \vdash \bsf{S}\,m\,n : \textsf{K}\,b\,r$}
          }
        \end{array}
      \end{array}
    \]
    \caption{Continuized CCG with side effects, fixing a monad \ab{\textsf{M},\,\eta,\,\star} and a result type $r$.}%
    \label{fig2}
	\end{subfigure}
  \caption{%
    Continuized CCGs with and without side effects, for a fixed result type
    $r$ and monad \ab{\textsf{M},\,\eta,\,\star}. In both grammars, $\bsf{S}\,m\,n \ceq \lambda k .\, m\,(\lambda f .\, n\,(\lambda x .\, k\,(f\,x)))$.
  }
\end{figure*}

%\end{sec}

\section{Adding side effects}
%\begin{sec}
  Continuized grammars do not place inherent restrictions on $r$, the type of the context. For simple cases where only boolean scope-taking is at-issue (cf.~\citealt{BarwiseCooper:1981}), we can set $r \Coloneqq t$. But in general, we may be interested in contexts that denote in richer semantic spaces, as is typically the case with questions, focus, attitude reports, dynamic updates, etc. In such cases, we enrich the return type to match the phenomenon of interest. % YASS

  We propose to model the sorts of semantic enrichments motivated by these phenomena using monads (\citealt{Wadler:1994, Liangetal}), which serve much the same purpose in capturing the semantics of programming language \emph{side effects} like IO\@. A monad is a triple \ab{\textsf{M},\,\eta,\,\star} of a type constructor \textsf{M}, an injection function $\eta$ of type $a \ra \textsf{M}\,a$ (given any type $a$), and a recipe for sequencing programs $\star$, of type $\textsf{M}\,a \ra (a \ra \textsf{M}\,b) \ra \textsf{M}\,b$ (given any types $a,b$). The monadic functors $\eta$ and $\star$ are required to satisfy the following three \emph{monad laws}, which ensure that $\eta\,x$ represents a \emph{trivial} injection of $x$ into the monad (left and right unit), and that order of evaluation, but not relative embedding, matters for program sequencing (a form of associativity): %
	\begin{defi}[Monad laws]%
		For any monad \ab{\textsf{M},\,\eta,\,\star}:
		\[\begin{array}{l@{}r@{}l}
			\text{Left unit: }&\eta\,x \star k &{}= k\,x
			\\
			\text{Right unit: }&m \star \eta &{}= m
			\\
			\text{Associativity: }&(m \star k) \star c &{}= m \star \lambda x.\,k\,x \star c%
		\end{array}\]
	\end{defi}
	
  Monads provide an elegant bridge between side effects and continuations, because the type of $(\star)$ is equivalent to $\textsf{M}\,a \ra \textsf{K}\,a\,(\textsf{M}\,b)$. The bind function is thus itself a means of lifting effectful programs into continuized programs. Similarly, the unit function doubles as a default continuation, always available to be passed in to $\textsf{K}\,a\,(\textsf{M}\,b)$ programs without generating any new side effects. In this way, we can construct continuized grammars directly from monads by trading in \bsf{Lift} for $\star$ and \bsf{Triv} for $\eta$. Conveniently, because \bsf{Scope} operates at the level of already continuized programs, it doesn't change.%	
	
  In fact, \bsf{Lift} is a theorem of any monadic grammar, when we restrict the result type to $\textsf{M}\,r$. Generally, for any monad \ab{\textsf{M},\,\eta,\,\star} and result type $r$:%
	\begin{fact}%
    $\Gamma \vdash x : a \Rightarrow \Gamma \vdash \lambda k.\,k\,x : \textsf{K}\,a\,(\textsf{M}\,r)$%
		%\begin{proof}
		%	Successive applications of $\eta$, $\star$.
		%\end{proof}
	\end{fact}
	\begin{fact}%
		$\begin{array}[t]{@{}r@{}l@{}}
			\bsf{S}\,((\star)\,m)\,&((\star)\,n)\,\eta 
			\\
			&{}= m \star \lambda f.\,n \star \lambda x.\,\eta\,(f\,x)%
			\\
		\end{array}$%
	\end{fact}
%\end{sec}

\section{Finding the dynamic monad}
%\begin{sec}
  We treat dynamic semantics as a case study for the monadic approach. Following \citet{Shan:2001}, we characterize dynamic systems as those that recognize some forms of mutable state and nondeterminism. The former provides a mechanism by which expressions can manipulate the discourse context, usually through the introduction of discourse referents. The latter guarantees that indefinites are handled on a par with referential expressions, but whose referents are generated ``randomly''.%
  \footnote{Dynamic treatments following \citealt{GroenendijkStokhof:1990} (e.g.~\citealt{Zimmermann:1991, Dekker:1993, Szabolcsi:2003, Groote:2006}) provide a way for indefinites to extend their binding domain but do not treat indefinites as nondeterministic analogs of proper names.}%
	
  In classic formulations of dynamic semantics (\citealt{Heim:1982, Kamp:1981, GroenendijkStokhof:1991, Dekker:1994}), sentences denote relations on sequences. Non-empty relations correspond to truthful updates. Indefinites (and perhaps disjunctions) generate nonfunctional (in our terms, ``nondeterministic'') relations, with inputs matched against multiple outputs. Sentential conjunction amounts to relation composition, which pipes the sequences output by the left conjunct pointwise into the right.%
  \begin{align}%
    \label{eq:classic-indef}%
		\sv{\text{someone}} &= \lambda ki.\displaystyle\bigcup_{\mathclap{x\in\,\textsf{person}}}k\,x\,(i + x)%
		\\
		\sv{\text{someone left}} &= \lambda i.\,\{i + x : x \in \textsf{person} \wedge x \in \textsf{left}\}%
    \notag
  \end{align}%

  The denotations in (\ref{eq:classic-indef}) illustrate the way in which the standard dynamic approach puts state and nondeterminism are put front and center. Sentences are in fact \emph{nothing but} nondeterministic modifications of state; even truth and falsity are derivative notions. Borrowing from the functional programming literature, we advocate a different perspective: treating nondeterminism and state modification as \emph{side effects}, associated with semantic values, rather than replacing them. 
	
  Here is the standard monad for state manipulation. Assume that $\gamma$ is the type of ``evaluation contexts''. For our purposes, we set $\gamma$ equal to the type of discourse referent sequences.%
	\begin{defi}[The State monad]\label{state}
		\[\begin{array}[t]
			{@{}l@{}c@{}l@{}}
			\textsf{M}\,a &{}\Coloneqq{} &\gamma \ra a \ast \gamma	%
			\\
			\eta\,x &{}\ceq{} &\lambda i.\,\ab{x,\,i}
			\\
			m \star k &{}\ceq{} &\lambda i.\,k\,(m\,i)_0\,(m\,i)_1%
		\end{array}\]
	\end{defi}
	
  To keep things simple, we model dref introduction as sequence extension \citep[cf.][]{Groote:2006, Unger:2012, Charlow:diss}, and dref retrieval as sequence projection. Again, for simplicity we assume a single projection function $\cdot_\top$ that picks out the most topical referent (for concreteness, the last).
	\begin{defi}[Dref introduction]
		\[m^\rhd \ceq m \star \lambda xi.\,\ab{x,\,i + x}\]
	\end{defi}
	\begin{defi}[Dref retrieval]
		\[\bsf{he} \ceq \lambda i.\,\ab{i_\top,\,i}\]
	\end{defi}
	
	An example, \emph{Al left} (call this \bsf{X}):
	\[(\eta\,\textsf{a})^\rhd\! \star \lambda x.\,\eta\,(\textsf{left}\,x) = \lambda i.\,\ab{\textsf{left}\,\textsf{a},\,i+\textsf{a}}\]%
	
	Pronoun sentence \emph{he was tired} (call this \bsf{Y}):
	\[\bsf{he} \star \lambda x.\,\eta\,(\textsf{tired}\,x) = \lambda i.\,\ab{\textsf{tired}\,i_\top,\,i}\]%
	
	Sequencing the two. The dref introduced by the proper name in the first sentence is accessed by the pronoun in the second. %
	\[\begin{array}{r@{}l}
		\bsf{X} \star \lambda p.\,\bsf{Y}&{}\star \lambda q.\,\eta\,(p \wedge q) %
		\\
		&{}= \lambda i.\,\ab{\textsf{left}\,\textsf{a} \wedge \textsf{tired}\,\textsf{a},\,i+\textsf{a}}%
	\end{array}\]
	
	So we have state modification as a side effect. To say something about indefinites, i.e.~to allow them to refer and introduce drefs nondeterministically, we need to enrich the state monad with nondeterministic side effects. The monad for nondeterminism is the Set monad, given in Definition \ref{set}:%
	\begin{defi}[The Set monad]\label{set}
		\[\begin{array}[t]
			{@{}l@{}c@{}l@{}}
			\textsf{M}\,a &{}\Coloneqq{} &a \ra t%
			\\
			\eta\,x &{}\ceq{} &\{x\}
			\\
			m \star k &{}\ceq{} &\displaystyle\bigcup_{\mathclap{x\in \,m}}k\,x%
		\end{array}\]
	\end{defi} 

	Use StateT to stitch the two together. Given any monad ${\cal M}= \ab{\textsf{L},\,\eta_\textsf{L},\,\star_\textsf{L}}$, StateT is a recipe for building a new monad with which adds State-type functionality to ${\cal M}$:\footnote{Fn. about SetT}. Result also known as the Parser monad. \citealt{HuttonMeijer}%
	\begin{defi}[The StateT monad transformer]\label{statet}
		\[\begin{array}[t]
			{@{}l@{}c@{}l@{}}
			\textsf{M}\,a &{}\Coloneqq{} &\gamma \ra \textsf{L}\,(a \times \gamma)%
			\\
			\eta\,x &{}\ceq{} &\lambda i .\,\eta_\textsf{L}\,\ab{x,\,i}
			\\
			m \star k &{}\ceq{} &\lambda i.\, m\,i\star_\textsf{L} \lambda \pi.\,k\,\pi_0\,\pi_1%
		\end{array}\]
	\end{defi}
	\begin{defi}[The State\_Set monad]\label{stateset}
		\[\begin{array}[t]
			{@{}l@{}c@{}l@{}}
			\textsf{M}\,a &{}\Coloneqq{} &\gamma \ra (a \times \gamma) \ra t%
			\\
			\eta\,x &{}\ceq{} &\lambda i.\left\{\ab{x,\,i}\right\}
			\\
			m \star k &{}\ceq{} &\lambda i.\displaystyle\bigcup_{\mathclap{\pi \in mi}}k\,\pi_0\,\pi_1%
		\end{array}\]
	\end{defi}

	Static lexicon, dynamic lexicon
	
	Modular treatment of binding.%
	\[\begin{array}{ll}
		\text{Previous}:& \bsf{bind}\,m \ceq \lambda k.\,m\,(\lambda x.\,k\,x\,x)%
		\\
		\text{Proposal}:& \bsf{bind}\,m \ceq \lambda k.\,m\,(\lambda xi.\,k\,x\,(i + x))%
	\end{array}\]
%\end{sec}

\section{Examples}
%\begin{sec}
	Cross-sentential anaphora. Let us assume that \emph{scope islands}, e.g., tensed clauses, need to be evaluated---i.e., lowered (cf.~\citealt{Barker:2002, BarkerShan:2008}). In practice, this means a tensed clause must pass through a stage where it denotes something of type $\textsf{M}\,t$. There are a variety of options for enforcing this syntactically, but here we concentrate on the semantic upshots of forced evaluation.\footnote{In terms of LF, forcing evaluation of a scope island corresponds to disallowing QR out of the scope island.} the indefinite's side effects influence the evaluation of the second clause, even as the indefinite scopes within its clause. See Figure \ref{fig:derivation}.%
%	\[\begin{array}{r}
%		\bsf{so.left} \star \lambda p.\,\bsf{he.tired} \star \lambda q.\,\eta\,(p \wedge q)%
%		\\
%		= \bsf{so} \star \lambda x.\,\eta\,(\textsf{left}\,x \wedge \textsf{tired}\,x)%
%	\end{array}\]
	\begin{figure*}
		%\begin{saveboxes}
		\newsavebox{\partbox}\setbox\partbox=\hbox{\scriptsize\pruf{%
				\AXC{$\bsf{so} : \textsf{M}\,e$}
				\lab{$\star$}
				\UIC{$\lambda k.\,\bsf{so} \star k : \textsf{K}\,e\,\textsf{M}\,t$}%
				\lab{$\rhd$}
				\UIC{$\lambda k.\,\bsf{so}^\rhd\! \star k : \textsf{K}\,e\,\textsf{M}\,t$}%
				\AXC{$\textsf{left} : e \backslash t$}
				\lab{$\uparrow$}
				\UIC{$\lambda k.\,k\,\textsf{left} : \textsf{K}\,(e \backslash t)\,\textsf{M}\,t$}%
				\lab{$\bbslash$}
				\BIC{$\lambda k.\,\bsf{so}^\rhd\! \star \lambda x.\,k\,(\textsf{left}\,x) : \textsf{K}\,t\,\textsf{M}\,t$}%
				\lab{$\downarrow$}
				\UIC{$\bsf{so}^\rhd\! \star \lambda x.\,\eta\,(\textsf{left}\,x) : \textsf{M}\,t$}%
				}}%
		\newsavebox{\partboxx}\setbox\partboxx=\hbox{\scriptsize\pruf{%
				\AXC{$\bsf{he} : \textsf{M}\,e$}
				\lab{$\star$}
				\UIC{$\lambda k.\,\bsf{he} \star k: \textsf{K}\,e\,\textsf{M}\,t$}%
				\AXC{$\textsf{tired} : e \backslash t$}
				\lab{$\uparrow$}
				\UIC{$\lambda k.\,k\,\textsf{tired} : \textsf{K}\,(e \backslash t)\,\textsf{M}\,t$}%
				\lab{$\bbslash$}
				\BIC{$\lambda k.\,\bsf{he} \star \lambda y.\,k\,(\textsf{tired}\,y) : \textsf{K}\,t\,\textsf{M}\,t$}%
				\lab{$\downarrow$}
				\UIC{$\bsf{he} \star \lambda y.\,\eta\,(\textsf{tired}\,y) : \textsf{M}\,t$}}}%
		%\end{saveboxes}
		{\small{\scriptsize\[\begin{array}{c}
			\pruf{%
			\AXC{$\boxed{\usebox\partbox}$}
			\lab{$\star$}
			\UIC{$\lambda k.\,\bsf{so}^\rhd\! \star \lambda x.\,k\,(\textsf{left}\,x) : \textsf{K}\,t\,\textsf{M}\,t$}%
			\AXC{$\textsf{and} : (t \backslash t)/t$}
			\lab{$\uparrow$}
			\UIC{$\lambda k.\,k\,\textsf{and} : \textsf{K}\,((t \backslash t)/t)\,\textsf{M}\,t$}%
			\AXC{$\boxed{\usebox\partboxx}$}
			\lab{$\star$}
			\UIC{$\lambda k.\,\bsf{he} \star \lambda y.\,k\,(\textsf{tired}\,y) : \textsf{K}\,t\,\textsf{M}\,t$}%
			\lab{$\sslash$}
			\BIC{$\lambda k.\,\bsf{he} \star \lambda y.\,k\,(\lambda p.\,p \wedge \textsf{tired}\,y) : \textsf{K}\,(t \backslash t)\,\textsf{M}\,t$}%
			\lab{$\bbslash$}
			\BIC{$\lambda k.\,\bsf{so}^\rhd\! \star \lambda x.\,\bsf{he} \star \lambda y.\,k\,(\textsf{left}\,x \wedge \textsf{tired}\,y) : \textsf{K}\,t\,\textsf{M}\,t$}%
			\lab{$\downarrow$}
			\UIC{$\bsf{so}^\rhd\! \star \lambda x.\,\bsf{he} \star \lambda y.\,\eta\,(\textsf{left}\,x \wedge \textsf{tired}\,y) : \textsf{M}\,t$}%
			\lab{equiv}
			\UIC{$\bsf{so}^\rhd\! \star \lambda x.\,\eta\,(\textsf{left}\,x \wedge \textsf{tired}\,x) : \textsf{M}\,t$}%
			}%
			\\[-1em]
		\end{array}\]}
		\caption{Cross-sentential anaphora: deriving \emph{someone$_i$ left; he$_i$ was tired.}}%
		\label{fig:derivation}}
	\end{figure*}
	
	Negation. Requires there to be no true boolean value returned, tosses out any discourse referents generated in its scope. (Standard). Use to define dynamically closed meanings (e.g.~conditional, universal quantifier, etc.) %
	\[\begin{array}{r@{}l}
		\bsf{not}&{}\ceq \lambda ms.\left\{\ab{\neg\exists \pi \in m\,s.\,\pi_0,\,s}\right\}%
		\\
		\bsf{no.ling}&{}\ceq \lambda k.\,\bsf{not}\,(\bsf{a.ling} \star k)%	
		\\
		\bsf{ev.ling}&{}\ceq \lambda k.\,\bsf{not}\,(\bsf{a.ling} \star \lambda x.\,\bsf{not}\,(k\,x))%
	\end{array}\]%
	
	Compare universals. After ending the derivation at the clause boundary, we're left with a pure computation. The universal's side effects have died on evaluation.%
	\[\eta\,(\forall x.\,\textsf{ling}\,x \Rightarrow \textsf{left}\,x)\]
	
	Donkey anaphora works similarly. Take the following. The restrictor $c$ here acquires a kind of monadic scope, via $\star$, over the nuclear scope $k$. This means any side effects inside $c$ influence the context of evaluation for $k$. However, once $k$ is grabbed, the wide-scoping negation discharges side effects (as is standard in dynamic systems). %	
	\[\bsf{every} \ceq \lambda ck.\,\bsf{not}\,(\bsf{a}\,c \star \lambda x.\,\bsf{not}\,(k\,x))\]%
%\end{sec}

\section{Discussion}
%\begin{sec}
	Compare PLA, where only sentences are imbued with context change potential. Necessary since in PLA and standard dynamic treatments of anaphora, discourse-level content and truth-conditional content are conflated---i.e.~a sentence denotes a non-empty relation on sequences iff the sentence is true. Thus: standard dynamic techniques (DPL, DMG) not reducible to monads. %
	
	Some upshots: no dynamic conjunction, completely standard model theory (cf.~\citealt{Groote:2006}). ``Contexts of evaluation'' are constructed on the fly. Variable-free, directly compositional (\citealt{Jacobson:1999}). %

	Monads as a natural way to extend a continuations-based grammar with tools for dynamic binding and exceptional scope. In the end: you have functional application, plus the functors from whichever monads are implicated in a given language. Effects recognized in the types. %

	There is no need to settle on a single (``the'') grammar. Different and quite varied side effects regimes can be modularly grafted onto a simple applicative (``pure'') core. Lexical entries that would seem incongruous in a flat-footed standard perspective integrate seamlessly in a single grammar. %
	
	Again, any sufficiently ``well-behaved'' (see Section~\ref{?}) regime of semantic enrichment (e.g.~focus-sensitivity, alternative-generation, intensionality) may be accommodated along similar lines. Furthermore, because of the inherent modularity of the monadic approach, various side effects may be added to or subtracted from the grammar without adjusting the basic compositional machinery or the lexical entries that are not sensitive to the effects in question. Therefore, we expect these results will be of interest for natural language semanticists of many stripes, in addition to categorial grammarians working on donkey anaphora and/or scope-taking. % SC: moved here from S1
	
	Theory extends to scope islands, wide range of exceptional binding configurations \citealt{Charlow:diss}. Extends to pair-list phenomena, functional quantification: \citealt{Bumford:inc}. Crossover, superiority less clear (cf.~\citealt{ShanBarker:2006, BarkerShan:2008}). %
	
	Broader question: how this relates to the idea that continuations can simulate any monad (\citealt{Filinski:1994}). I don't understand this result well enough to say anything (Dylan?). %
%\end{sec}

{\small\bibliography{bqhatevwr}}
\end{document}
